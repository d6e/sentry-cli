mod api;
mod cli;
mod config;
mod error;
mod output;

use std::error::Error;

use clap::{CommandFactory, Parser};
use clap_complete::generate;
use cli::args::{Cli, Commands, ConfigCommands, IssuesCommands};
use cli::commands::{config as config_cmd, issues};
use config::load_config;
use output::print_error;

#[tokio::main(flavor = "current_thread")]
async fn main() {
    if let Err(e) = run().await {
        print_error(&e.to_string());

        // Show error chain if verbose flag was passed
        if std::env::args().any(|arg| arg == "--verbose" || arg == "-v") {
            let mut source = e.source();
            while let Some(cause) = source {
                eprintln!("Caused by: {cause}");
                source = cause.source();
            }
        }

        std::process::exit(1);
    }
}

async fn run() -> error::Result<()> {
    let cli = Cli::parse();
    let config = load_config();

    // Set global output format and quiet mode
    output::set_format(cli.format);
    output::set_quiet(cli.quiet);

    match cli.command {
        Commands::Issues { command } => {
            let client = api::SentryClient::new(
                &config,
                cli.org.as_deref(),
                cli.server.as_deref(),
                cli.token.as_deref(),
                cli.verbose,
            )?;

            match command {
                IssuesCommands::List {
                    project,
                    status,
                    query,
                    sort,
                    limit,
                    all,
                } => {
                    let options = issues::ListOptions {
                        project,
                        status,
                        query,
                        sort,
                        limit,
                        all,
                    };
                    issues::list_issues(&client, options).await?;
                }
                IssuesCommands::View { issue_id } => {
                    issues::view_issue(&client, &issue_id).await?;
                }
                IssuesCommands::Resolve {
                    issue_ids,
                    in_release,
                    in_next_release,
                } => {
                    issues::resolve_issues(&client, issue_ids, in_release, in_next_release).await?;
                }
                IssuesCommands::Unresolve { issue_ids } => {
                    issues::unresolve_issues(&client, issue_ids).await?;
                }
                IssuesCommands::Assign {
                    issue_ids,
                    to,
                    unassign,
                } => {
                    issues::assign_issues(&client, issue_ids, to, unassign).await?;
                }
                IssuesCommands::Ignore {
                    issue_ids,
                    duration,
                    count,
                    until_escalating,
                } => {
                    issues::ignore_issues(&client, issue_ids, duration, count, until_escalating)
                        .await?;
                }
                IssuesCommands::Delete { issue_ids, confirm } => {
                    issues::delete_issues(&client, issue_ids, confirm).await?;
                }
                IssuesCommands::Merge {
                    primary_id,
                    other_ids,
                } => {
                    issues::merge_issues(&client, primary_id, other_ids).await?;
                }
            }
        }
        Commands::Config { command } => match command {
            ConfigCommands::Init => {
                config_cmd::init_config()?;
            }
            ConfigCommands::Show => {
                config_cmd::show_config()?;
            }
            ConfigCommands::Set { key, value } => {
                config_cmd::set_config(&key, &value)?;
            }
        },
        Commands::Completions { shell } => {
            let mut cmd = Cli::command();
            generate(shell, &mut cmd, "sentry", &mut std::io::stdout());
        }
    }

    Ok(())
}
